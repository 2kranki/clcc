#include <stdio.h>
#include <errno.h>
#include <stdlib.h>

#include "CLObject.clc"
#include "CLString.clc"
#include "CLObjectList.clc"
#include "CLStringObjectList.clc"

#include "Token.clc"
#include "Creator.clc"
#include "Analyzer.clc"
#include "Tokenizer.clc"
#include "Constants.clc"
#include "FileElements.clc"
#include "ClassElements.clc"


Main:CLObject
{

	Creator*			creator;
	Analyzer*			analyzer;
	Tokenizer*			tokenizer;
	FileElements*		collector;
    Constants*          constants;
	CLString*           targetPath;
	CLObjectList*		pathsList;


	// constructor , app entering point

	int init (	int			theCount , 
				const char* theTokens[ ]  )
	{

		printf( "clcc 0.7 by Milan Toth\n" );
	
		int    count  = theCount;
		char** tokens = (char**) theTokens;
		
		//-- debug

//		char* dbgtokens[18] =
//		{
//				"clc0.7" ,
//				"Scene" ,
//				"-p" , "/Users/milgra/Desktop/Cloud/Work/CodeBase/Cortex/" ,
//				"-p" , "/Users/milgra/Desktop/Cloud/Work/CodeBase/Library/CoreLib/" ,
//				"-p" , "/Users/milgra/Desktop/Cloud/Work/CodeBase/Library/MathLib/" , 
//				"-p" , "/Users/milgra/Desktop/Cloud/Work/CodeBase/Library/PhysicsLib/" ,
//				"-p" , "/Users/milgra/Desktop/Cloud/Work/CodeBase/Library/TextLib/" ,
//				"-p" , "/Users/milgra/Desktop/Cloud/Work/CodeBase/Library/GraphicsLib/" ,
//				"-p" , "/Users/milgra/Desktop/Cloud/Work/CodeBase/Library/GraphicsLib/Primitives/" ,
//				"-o" , "/Users/milgra/Desktop/Cloud/Work/CodeBase/Cortex/"
//		};
//
//		count  = 18;
//		tokens = dbgtokens;

		//-- debug

		if ( count > 1 )
		{

			// alloc members

			creator		 = Creator:alloc( );        // needs release
			analyzer	 = Analyzer:alloc( );       // needs release
			tokenizer	 = Tokenizer:alloc( );      // needs release
			collector    = FileElements:alloc( );   // needs release
            constants    = Constants:alloc( );      // needs release
			targetPath	 = CLString:alloc( );       // needs release
			pathsList	 = CLObjectList:alloc( );  // needs release

            // initialize

            creator:init( );
            analyzer:init( );
            tokenizer:init( );
            collector:init( );
            constants:init( );
            targetPath:init( );
            pathsList:init( );
            
            analyzer.constants = constants;
						
			// analyze parameters

            analyzeParameters( tokens , count );

			// compile
            
            for ( CLObject* object : collector.classesList )
            {

                // class's file elements
			
				FileElements* fileElements = FileElements:alloc( ); 
				fileElements:init( );

                // compile

				compileClass( ( CLString* ) object , fileElements );
					 
				// filter duplicate settings and add them to collector

				filterAndAddSettings( 
					fileElements.settingsList ,
					fileElements.settingNamesList ,
					collector.settingsList ,
					collector.settingNamesList );

				// add all non-present used classes to allClassesList, to compile every occuring class
				
				CLStringObjectList:addStringsAsUnique( 
					NULL , 
					fileElements.classesList ,
					collector.classesList );

				// add structures and methods
						
				collector.functionsList.addObjectsInObjectList( fileElements.functionsList );		
				collector.structuresList.addObjectsInObjectList( fileElements.structuresList );
				collector.functionHeadersList.addObjectsInObjectList( fileElements.functionHeadersList );		
				collector.structureHeadersList.addObjectsInObjectList( fileElements.structureHeadersList );
				
				// cleanup
				
				fileElements:release( );

			}
            
            // debug
			
			// collector.describe( );
            
            // write files
			
			writeFiles( collector );
			
			// cleanup

			creator:release( );
            analyzer:release( );
            tokenizer:release( );
			collector:release( );
            constants:release( );
			targetPath:release( );
			pathsList:release( );
		
		}
		else printf( "Usage : clcc ClassNameA ClassNameB ClassNameN -p SourcePathA -p SourcePathB -p SourcePathN -o OutputPath" );
		
		// new line for the terminal output
		
		printf( "\n" );

		return 0;
		
	}
    
    
    // analyze parameters
    
    void analyzeParameters( char** theTokens ,
                            int    theCount )
    {

        int    index  = 1;
		int    count  = theCount;
		char** tokens = theTokens;
        
        // print parameters for feedback

        printf( "\n" );
        
        for ( index = 1 ;
              index < count ;
              index++ )
        {
            printf( "%s " , tokens[index] );
            if ( tokens[ index ][ 0 ] != '-' ) printf( "\n" );
        }
        
        // analyze tokens
        
        index = 1;
        while ( index < count )
        {
        
            char* token = tokens[ index ];
            
            if ( token[ 0 ] == '-' )
            {
            
                // check switches
            
                if ( token[ 1 ] == 'p' && index < count - 1)
                {

                    // path

                    CLString* onePath = CLString:alloc( );
                    onePath:init( );
                    onePath:appendCString( tokens[ index + 1 ] );
                    
                    pathsList:addObject( ( CLObject* ) onePath );
                    
                    onePath:release( );
                    index += 1;

                }
                else if ( token[ 1 ] == 'o' && index < count - 1 )
                {
                
                    // output path
                
                    targetPath:appendCString( tokens[ index + 1 ] );
                    index += 1;
                    
                }

            }
            else
            {
            
                // token without minus is class

                CLString* oneClass = CLString:alloc( );
                oneClass:init( );
                oneClass:appendCString( tokens[ index ] );
                
                collector.classesList.addObject( ( CLObject* ) oneClass );
                
                oneClass:release( );
            
            }
            
            index += 1;
        
        }
        
        // set default path values if needed
        
        if ( pathsList.length == 0 )
        {
        
            CLString* onePath = CLString:alloc( );
            onePath:init( );
            pathsList:addObject( ( CLObject* ) onePath );
            
        }
		
		if ( targetPath.length == 0 || (targetPath.last)->character == '/' || (targetPath.last)->character == '\\' )
		{
			targetPath.appendCString( "clcsrc" );
		}
    
    }


	// compiles given class into settings, structures and methods
	
	void compileClass(  CLString*       theClassName ,
                        FileElements*	theFileElements )
	{
	
		printf( "\ncompiling class " );
		theClassName.describe( );
        
        // alloc instances

		ClassElements* classElements	   = ClassElements:alloc( );	// needs release
		CLObjectList* parentNamesList	   = CLObjectList:alloc( );	// needs release
		CLObjectList* parentElementsList = CLObjectList:alloc( );	// needs release
        
        // initialize
        
        classElements:init( theClassName );
        parentNamesList:init( );
        parentElementsList:init( );

		// start parent names with the class name itself
		
		parentNamesList:addObject( ( CLObject* ) theClassName );

		// read up classes, analyze their structure and organize them
        
        for ( CLObject* object : parentNamesList )
        {

			createAndOrganizeLines(
				( CLString* ) object ,
				classElements ,
				parentNamesList ,
				parentElementsList );

		}

        // add used classes in unused classes chain
        
        classElements.unusedClassNamesList.addObjectsInObjectList( classElements.usedClassNamesList );
        CLStringObjectList:removeStrings( NULL , parentNamesList , classElements.unusedClassNamesList );

		// detect language elements in members

		analyzer:analyzeMembers( classElements );

		// detect language elements in methods

		analyzer:analyzeMethods( classElements );

		// creates class, instance structs and struct forward declarations
		
		creator:createStructures(	  classElements , 
									  parentNamesList ,
									  parentElementsList ,
									  theFileElements.structuresList ,
									  theFileElements.structureHeadersList );

		// creates class allocator, instance allocator and other methods and function headers also 

		creator:createFunctions(	  classElements ,
									  parentNamesList ,
									  parentElementsList ,
									  theFileElements.functionsList ,
									  theFileElements.functionHeadersList );
								
		// add classes and settings to target chains

		theFileElements.classesList.addObjectsInObjectList( classElements.usedClassNamesList );
		theFileElements.settingsList.addObjectsInObjectList( classElements.settingTokensList );
		theFileElements.settingNamesList.addObjectsInObjectList( classElements.settingNamesList );
        
        // show unused classes
        
        if ( classElements.unusedClassNamesList.length > 0 )
        {
        
            printf( "\nWARNING : Unused classses : " );
            classElements.unusedClassNamesList.describe( );
            
        }
		
        // debug
		
//		classElements.describe( );
		
		// cleanup
		
		classElements:release( );
		parentNamesList:release( );
		parentElementsList:release( );
		
		printf( "\n" );
		theClassName.describe( );
		printf( " compiled" );

	}
	
	
	// creates statements for a class and organizes them
	
	void createAndOrganizeLines(   CLString*	   theClassName ,
                                        ClassElements* theElements ,
                                        CLObjectList* theParentNamesList ,
                                        CLObjectList* theParentElementsList )
	{

		CLObjectList* statements = CLObjectList:alloc( );	// needs release
        statements:init( );
        
        // read up file into statements
        
		getLinesForClass( theClassName , statements );
		
		if ( statements.length > 0 )
		{
			
			ClassElements* parentElements	 = ClassElements:alloc( );  // needs release
			CLObjectList* parentNamesList  = CLObjectList:alloc( );  // needs release

            parentElements:init( theClassName );
            parentNamesList:init( );

			// extract elements from statements

			analyzer.organizeTokens(	statements ,
										parentElements ,
										parentNamesList );

			// store elements
			
			theParentElementsList:addObject( ( CLObject* ) parentElements );

			// add compositing classes to classnameschain to emerge in all compositing classes recursively

			CLStringObjectList:addStringsAsUnique( NULL , parentNamesList , theParentNamesList );
			CLStringObjectList:addStringsAsUnique( NULL , parentElements.usedClassNamesList , theElements.usedClassNamesList );

			// combine settings and setting names in one chain
			
			theElements.settingNamesList.addObjectsInObjectList( parentElements.settingNamesList );
			theElements.settingTokensList.addObjectsInObjectList( parentElements.settingTokensList );

			struct CLLink* nameLink = parentElements.memberNamesList.head;
			struct CLLink* dataLink = parentElements.memberTokensList.head;
			
			// combine members and member names in one chain

			while ( nameLink != NULL )
			{

				CLString* name = ( CLString* ) nameLink->data;
				long long index = CLStringObjectList:indexOfString( NULL , name , theElements.memberNamesList );

				if ( index == -1 || name:equals( constants.settingString ) == 1 )
				{
					theElements.memberNamesList.addObject( nameLink->data );
					theElements.memberTokensList.addObject( dataLink->data );
				}
				else
				{
					printf( "\nERROR member collision : %s" , name.cString( ) );
					exit( 1 );
				}

				nameLink = nameLink->next;
				dataLink = dataLink->next;

			}

			nameLink = parentElements.methodNamesList.head;
			dataLink = parentElements.methodTokensList.head;

			// combine methods and method names in one chain
			
			while ( nameLink != NULL )
			{
            
				CLString* name = ( CLString* ) nameLink->data;
				long long index = CLStringObjectList:indexOfString( NULL , name , theElements.methodNamesList );
				
				if ( index == -1 )
				{

					theElements.methodNamesList.addObject( nameLink->data );
					theElements.methodTokensList.addObject( dataLink->data );

				}
				
				nameLink = nameLink->next;
				dataLink = dataLink->next;
                
			}
			
			// cleanup
			
			parentElements:release( );
			parentNamesList:release( );

		}
		else exit( 1 );	// class not found
		
		statements:release( );
		
	}
	
	
	// reads up file and breaks into statements
	
	void getLinesForClass(  CLString*		theClassName ,
							CLObjectList*	theLines )
	{
	
        for ( CLObject* object : pathsList )
        {
		
			CLString* path = ( CLString* ) object;
			CLString* filePath;
			CLString* classSource;
			
			filePath = CLString:alloc( );		// needs release
			filePath:init( );
			filePath.appendString( path );
			filePath.appendString( theClassName );
			filePath.appendCString( ".clc" );
			
			char* fileName = filePath.cString( );
			FILE* classFile = fopen( fileName , "r" );
			
            filePath:release( );

			if ( classFile != NULL )
            {

                printf( "\nReading " );
				theClassName.describe( );
                printf( " at %s" , fileName );
                
                classSource = CLString:alloc( );	// needs release
                classSource:init( );
                classSource:readFilePointer( classFile );

                fclose( classFile );
                
                tokenizer.createLines( classSource , theLines );

                free( fileName );
                classSource:release( );

                return;
                
            }
            
			free( fileName );
			
		}

		printf( "\nSource not found for class : %s" , theClassName.cString( ) );
	
	}
    
	
	// filters settings and adds them to global collector
	
	void filterAndAddSettings(  CLObjectList* theCombinedSettingsList ,
                                CLObjectList* theCombinedSettingNamesList ,
                                CLObjectList* theSettingsList ,
                                CLObjectList* theSettingNamesList )
	{

		struct CLLink* nameLink 	= theCombinedSettingNamesList.head;
		struct CLLink* settingLink 	= theCombinedSettingsList.head;

		char inIfdef = 0;

		while ( settingLink != NULL )
		{
		
			CLString*		settingName = ( CLString* ) nameLink->data;
			CLObjectList*	settings 	= ( CLObjectList* ) settingLink->data;
			
			if ( settingName.indexOfString( constants.classString ) == -1 )
			{

				long long index = CLStringObjectList:indexOfString( NULL , settingName , theSettingNamesList );

				if ( settingName.indexOfString( constants.ifdefString ) == 0 ) inIfdef = 1;
				
				if ( inIfdef == 1 || ( inIfdef == 0 && index == -1 ) )
				{
				
					theSettingNamesList.addObject( ( CLObject* ) settingName );
					theSettingsList.addObject( ( CLObject* ) settings );
				
				}
				
				if ( settingName.indexOfString( constants.endifString ) == 0 ) inIfdef = 0;
				
			}

			nameLink    = nameLink->next;
			settingLink = settingLink->next;

		}
	
	}
	
	
	// writes files
	
	void writeFiles( FileElements* theFileElements )
	{
			
		// write header

		CLString* filePath = CLString:alloc( );
        filePath.init( );
		filePath.appendString( targetPath );
		filePath.appendCString( ".h" );
        
        char* fileCString = filePath.cString( );
		FILE* filePointer = fopen( fileCString , "w" );
		
		if ( filePointer == NULL ) 
		{
            printf( "Cannot write header at %s, errno : %i" , fileCString , errno );
            return;
		}
		else printf( "\nWriting header to %s" , fileCString );
		
        free( fileCString );
		filePath:release( );

		// write ifndef
		
		fputs( "#ifndef clcsrc_h\n" , filePointer );
		fputs( "#define clcsrc_h\n" , filePointer );
		
		// settings

		fputs( "#include <stdio.h>\n" , filePointer );
		fputs( "#include <stdlib.h>\n" , filePointer );

        for ( CLObject* object : theFileElements.settingNamesList )
        {
		
			CLString* oneLine = ( CLString* ) object;
			oneLine:writeToFilePointer( filePointer );
			fputs( "\n" , filePointer );
		
		}
		
		// general structs
		
		fputs( creator:createGeneralStructs( ) , filePointer );
		
		// structure headers
		
        for ( CLObject* object : theFileElements.structureHeadersList )
        {
		
			CLString* oneLine = ( CLString* ) object;
			oneLine:writeToFilePointer( filePointer );
		
		}
		
		// structures
		
        for ( CLObject* object : theFileElements.structuresList )
        {
		
			CLString* oneLine = ( CLString* ) object;
			oneLine:writeToFilePointer( filePointer );
		
		}
		
		// cast and free headers
		
		fputs( "void* cast_object( void* theObject , void* theId );\n" , filePointer );
		fputs( "void  free_object( void* theObject );\n" , filePointer );
		
		// function headers

        for ( CLObject* object : theFileElements.functionHeadersList )
        {
		
			CLString* oneLine = ( CLString* ) object;
			oneLine:writeToFilePointer( filePointer );
		
		}

		fputs( "#endif\n" , filePointer );
		
		fclose( filePointer );
		
		// write implementation
		
		filePath = CLString:alloc( ); 
		filePath:init( );
        filePath.appendString( targetPath );
        filePath.appendCString( ".c" );
        
        fileCString = filePath.cString( );
		filePointer = fopen( fileCString , "w" );
		
		if ( filePointer == NULL ) 
		{
            printf( "Cannot write implementation at %s, errno : %i" , fileCString , errno );
            return;
		}
		else printf( "\nWriting implementation to %s" , fileCString );
		
        free( fileCString );
		filePath:release( );

		// write include
		
		fputs( "#include \"clcsrc.h\"\n" , filePointer );		
		
		// get_component

		fputs( creator:createCasterMethod( ) , filePointer );
		fputs( creator:createDeallocatorMethod( ) , filePointer );
		
		// class instances
		
        for ( CLObject* object : theFileElements.classesList )
        {

			// static struct CLObject_Class* CLObject_ClassInstance= NULL;
		
			CLString* oneClass = ( CLString* ) object;
			fputs( "static struct " , filePointer );
			oneClass:writeToFilePointer( filePointer );
			fputs( "_Class* " , filePointer );
			oneClass:writeToFilePointer( filePointer );
			fputs( "_ClassInstance = NULL;\n" , filePointer );
		
		}
		
		// functions
		
        for ( CLObject* object : theFileElements.functionsList )
        {
		
			CLString* oneFunction = ( CLString* ) object;
			oneFunction:writeToFilePointer( filePointer );		
		
		}
		
		fclose( filePointer );

	}

}